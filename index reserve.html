<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Album Covers Gallery</title>
    
    <style>
:root {
  --cover-size: 300px;
}

/* Animation that rotates the cover */
@keyframes rotate-cover {
  0% {
    transform: translateX(-100%) rotateY(-45deg);
  }
  35% {
    transform: translateX(0) rotateY(-45deg);
  }
  50% {
    transform: rotateY(0deg) translateZ(1em) scale(1.5);
  }
  65% {
    transform: translateX(0) rotateY(45deg);
  }
  100% {
    transform: translateX(100%) rotateY(45deg);
  }
}

/* Animation that adjusts z-index */
@keyframes adjust-z-index {
  0% { z-index: 1; }
  50% { z-index: 100; }
  100% { z-index: 1; }
}

/* Container setup */
.cards-wrapper {
  perspective: 40em;
  overflow: hidden;
  user-select: none;
  cursor: grab;
}
.cards-wrapper:active {
  cursor: grabbing;
}

.cards {
  transform-style: preserve-3d;
  list-style: none;
  white-space: nowrap;
  overflow-x: auto;
  scroll-snap-type: x mandatory;
  scroll-behavior: smooth;
  padding: 20px 0;
  margin: 0;
  height: 400px;
}

/* Hide scrollbar */
.cards::-webkit-scrollbar {
  display: none;
}
.cards {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

/* List item setup */
.cards li {
  transform-style: preserve-3d;
  display: inline-block;
  width: var(--cover-size);
  aspect-ratio: 1;
  scroll-snap-align: center;
  margin: 0 20px;
  
  view-timeline-name: --li-in-and-out-of-view;
  view-timeline-axis: inline;
  
  animation: adjust-z-index linear both;
  animation-timeline: --li-in-and-out-of-view;
  perspective: 40em;
}

/* Image styling and animation */
.cards li img {
  width: 100%;
  height: auto;
  
  -webkit-box-reflect: below 0.5em linear-gradient(transparent, rgba(0,0,0,0.25));
  
  animation: rotate-cover linear both;
  animation-timeline: --li-in-and-out-of-view;
  
  transform: translateX(-100%) rotateY(-45deg);
  transform-style: preserve-3d;
  will-change: transform;
  
  position: relative;
  user-select: none;
  border-radius: 10px;
  transition: transform 0.1s ease;
}

/* Active state for dragging */
.cards-wrapper.dragging .cards li img {
  transition: none;
}

.instructions {
  text-align: center;
  color: #666;
  margin-top: 20px;
  font-family: Arial, sans-serif;
}
    </style>
</head>
<body>
    <div class="cards-wrapper" id="cardsWrapper">
        <ul class="cards" id="cardsContainer">
            <!-- Карточки будут добавлены через JavaScript -->
        </ul>
    </div>
    
    <div class="instructions">
        Перетаскивайте мышью для прокрутки • Бесконечная галерея
    </div>

    <!-- Полифил для Scroll-driven Animations -->
    <script src="https://flackr.github.io/scroll-timeline/dist/scroll-timeline.js"></script>
    
    <script>
        // Массив с путями к изображениям
        const images = [
            'images/post1.jfif',
            'images/post2.jfif', 
            'images/post3.jfif',
            'images/post4.jfif',
            'images/post5.jfif',
            'images/post6.jfif'
        ];

        const container = document.getElementById('cardsContainer');
        const wrapper = document.getElementById('cardsWrapper');
        
        // Создаем дубликаты для бесконечного скролла
        const allImages = [...images, ...images, ...images];
        
        // Добавляем карточки в контейнер
        allImages.forEach((src, index) => {
            const li = document.createElement('li');
            li.innerHTML = `
                <img draggable="false" 
                    src="${src}" 
                    width="1200" height="1200" 
                    alt="Album cover ${(index % images.length) + 1}" />
            `;
            container.appendChild(li);
        });

        // Переменные для drag functionality
        let isDragging = false;
        let startX;
        let scrollLeft;
        let velocity = 0;
        let lastX;
        let animationFrame;
        let lastTime;

        // Функция для бесконечного скролла
        function handleInfiniteScroll() {
            const cardWidth = 300 + 40; // width + margin
            const middleSection = images.length * cardWidth;
            const scrollLeft = container.scrollLeft;
            const maxScroll = container.scrollWidth - container.clientWidth;
            
            // Если достигли конца (третья копия), переходим к началу второй копии
            if (scrollLeft >= middleSection * 2) {
                container.scrollLeft = middleSection + (scrollLeft - middleSection * 2);
            }
            // Если достигли начала (первая копия), переходим к концу второй копии  
            else if (scrollLeft <= 0) {
                container.scrollLeft = middleSection + scrollLeft;
            }
        }

        // Mouse/touch event handlers
        function startDrag(e) {
            isDragging = true;
            wrapper.classList.add('dragging');
            
            startX = (e.pageX || e.touches[0].pageX) - container.offsetLeft;
            scrollLeft = container.scrollLeft;
            lastX = startX;
            lastTime = Date.now();
            
            // Отменяем любую активную анимацию
            cancelAnimationFrame(animationFrame);
            velocity = 0;
        }

        function duringDrag(e) {
            if (!isDragging) return;
            
            e.preventDefault();
            const x = (e.pageX || e.touches[0].pageX) - container.offsetLeft;
            const walk = (x - startX) * 2; // Multiply for better sensitivity
            
            container.scrollLeft = scrollLeft - walk;
            
            // Calculate velocity for momentum
            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            if (deltaTime > 0) {
                velocity = (lastX - x) / deltaTime;
            }
            lastX = x;
            lastTime = currentTime;
            
            handleInfiniteScroll();
        }

        function endDrag() {
            isDragging = false;
            wrapper.classList.remove('dragging');
            
            // Apply momentum
            applyMomentum();
        }

        function applyMomentum() {
            if (Math.abs(velocity) < 0.1) return;
            
            velocity *= 0.95; // friction
            
            container.scrollLeft -= velocity * 16;
            
            handleInfiniteScroll();
            
            if (Math.abs(velocity) > 0.1) {
                animationFrame = requestAnimationFrame(applyMomentum);
            }
        }

        // Event listeners
        wrapper.addEventListener('mousedown', startDrag);
        wrapper.addEventListener('touchstart', startDrag);

        window.addEventListener('mousemove', duringDrag);
        window.addEventListener('touchmove', duringDrag);

        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);

        // Prevent default drag behavior
        wrapper.addEventListener('dragstart', (e) => e.preventDefault());

        // Инициализация - стартуем в середине
        window.addEventListener('load', () => {
            const cardWidth = 300 + 40;
            const middleSection = images.length * cardWidth;
            container.scrollLeft = middleSection;
        });

        // Также обрабатываем скролл колесом мыши
        container.addEventListener('scroll', handleInfiniteScroll);

        // Добавляем инерцию при скролле колесом
        let wheelTimeout;
        container.addEventListener('wheel', (e) => {
            // Позволяем нормальный скролл, но добавляем плавность
            clearTimeout(wheelTimeout);
            wrapper.classList.add('dragging');
            
            wheelTimeout = setTimeout(() => {
                wrapper.classList.remove('dragging');
                handleInfiniteScroll();
            }, 100);
        });
    </script>
</body>
</html>